{"remainingRequest":"/Users/joey/Projects/qwinto/client/node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/index.js??ref--0-1!/Users/joey/Projects/qwinto/client/src/App.vue?vue&type=template&id=7ba5bd90&bindings={\"error\":\"data\",\"userLeft\":\"data\",\"totalScores\":\"data\",\"dices\":\"data\",\"checkedColors\":\"data\",\"checkActivePlayer\":\"options\",\"gameOver\":\"options\",\"activePlayer\":\"options\",\"errorType\":\"options\",\"botOwnTurn\":\"options\",\"botOthersTurn\":\"options\",\"startGame\":\"options\",\"passDiceColors\":\"options\",\"calcScores\":\"options\",\"calcBonus\":\"options\",\"handleError\":\"options\",\"simulateTurn\":\"options\",\"addBotScore\":\"options\",\"pushScore\":\"options\",\"originalPosition\":\"options\",\"shuffle\":\"options\"}","dependencies":[{"path":"/Users/joey/Projects/qwinto/client/src/App.vue","mtime":1668154010653},{"path":"/Users/joey/Projects/qwinto/client/node_modules/cache-loader/dist/cjs.js","mtime":1668178923236},{"path":"/Users/joey/Projects/qwinto/client/node_modules/babel-loader/lib/index.js","mtime":1668178923523},{"path":"/Users/joey/Projects/qwinto/client/node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/templateLoader.js","mtime":1668178927054},{"path":"/Users/joey/Projects/qwinto/client/node_modules/cache-loader/dist/cjs.js","mtime":1668178923236},{"path":"/Users/joey/Projects/qwinto/client/node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/index.js","mtime":1668178926998}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgPHRoZS1oZWFkZXIgdi1pZj0ibnVtUGxheWVycyI+PC90aGUtaGVhZGVyPgogIDxzdGFydC1mb3JtIHYtaWY9Im51bVBsYXllcnMgPT09IDAiIEBzdGFydC1nYW1lPSJzdGFydEdhbWUiPjwvc3RhcnQtZm9ybT4KICA8c2NvcmUtY2FyZAogICAgdi1mb3I9IihwbGF5ZXIsIGkpIGluIGdhbWVEYXRhIiAKICAgIDprZXk9ImkiIAogICAgOnBsYXllcj0iaSIKICAgIDpnYW1lLW92ZXI9ImdhbWVPdmVyIgogICAgcmVmPSJjYXJkIj4KICAgIDx0ZW1wbGF0ZSAjZGVmYXVsdD4KICAgICAgPGF2YWlsYWJsZS1hY3Rpb25zIDpjaGVja2VkLWNvbG9ycz0iY2hlY2tlZENvbG9ycyIgdi1pZj0iY2hlY2tBY3RpdmVQbGF5ZXIgJiYgIWdhbWVPdmVyIj48L2F2YWlsYWJsZS1hY3Rpb25zPgogICAgPC90ZW1wbGF0ZT4gCiAgICA8dGVtcGxhdGUgI2NvbnRyb2w+CiAgICAgIDxjb250cm9sLXBhbmVsIAogICAgICAgIEBkaWNlcy1jaGFuZ2U9InBhc3NEaWNlQ29sb3JzIgogICAgICAgIHYtaWY9ImNoZWNrQWN0aXZlUGxheWVyICYmICFnYW1lT3ZlciIKICAgICAgICByZWY9ImNvbnRyb2xEaWNlcyI+CiAgICAgIDwvY29udHJvbC1wYW5lbD4KICAgIDwvdGVtcGxhdGU+IAogIDwvc2NvcmUtY2FyZD4KICA8dG90YWwtcmVzdWx0cyB2LWlmPSJnYW1lT3ZlciIgOnRvdGFsLXNjb3Jlcz0idG90YWxTY29yZXMiPjwvdG90YWwtcmVzdWx0cz4KICA8YmFzZS1kaWFsb2cgOnNob3c9IiEhZXJyb3IiIDp0eXBlPSJlcnJvclR5cGUiIDp0aXRsZT0iJHQoJ2dhbWUubm90aWZpY2F0aW9uJykiIEBjbG9zZT0iaGFuZGxlRXJyb3IiPgogICAgPHRlbXBsYXRlICNkZWZhdWx0PgogICAgICA8cD57eyBlcnJvciB9fTwvcD4KICAgIDwvdGVtcGxhdGU+CiAgICA8dGVtcGxhdGUgI2FjdGlvbnM+CiAgICAgIDxiYXNlLWJ1dHRvbiBAY2xpY2s9ImhhbmRsZUVycm9yIj5PSzwvYmFzZS1idXR0b24+CiAgICA8L3RlbXBsYXRlPgogIDwvYmFzZS1kaWFsb2c+Cg=="},{"version":3,"sources":["/Users/joey/Projects/qwinto/client/src/App.vue"],"names":[],"mappings":"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C;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAChB,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC","file":"/Users/joey/Projects/qwinto/client/src/App.vue","sourceRoot":"","sourcesContent":["<template>\n  <the-header v-if=\"numPlayers\"></the-header>\n  <start-form v-if=\"numPlayers === 0\" @start-game=\"startGame\"></start-form>\n  <score-card\n    v-for=\"(player, i) in gameData\" \n    :key=\"i\" \n    :player=\"i\"\n    :game-over=\"gameOver\"\n    ref=\"card\">\n    <template #default>\n      <available-actions :checked-colors=\"checkedColors\" v-if=\"checkActivePlayer && !gameOver\"></available-actions>\n    </template> \n    <template #control>\n      <control-panel \n        @dices-change=\"passDiceColors\"\n        v-if=\"checkActivePlayer && !gameOver\"\n        ref=\"controlDices\">\n      </control-panel>\n    </template> \n  </score-card>\n  <total-results v-if=\"gameOver\" :total-scores=\"totalScores\"></total-results>\n  <base-dialog :show=\"!!error\" :type=\"errorType\" :title=\"$t('game.notification')\" @close=\"handleError\">\n    <template #default>\n      <p>{{ error }}</p>\n    </template>\n    <template #actions>\n      <base-button @click=\"handleError\">OK</base-button>\n    </template>\n  </base-dialog>\n</template>\n\n<script>\nimport TheHeader from \"./components/TheHeader.vue\";\nimport StartForm from \"./components/StartForm.vue\";\nimport ScoreCard from \"./components/ScoreCard.vue\";\nimport ControlPanel from \"./components/ControlPanel.vue\";\nimport AvailableActions from \"./components/AvailableActions.vue\";\nimport TotalResults from \"./components/TotalResults.vue\";\nimport { mapActions, mapGetters } from 'vuex';\nimport scoreMixin from './mixins/score.js';\n\nexport default {\n  name: \"App\",\n  components: {\n    TheHeader,\n    StartForm,\n    ScoreCard,\n    ControlPanel,\n    AvailableActions,\n    TotalResults\n  },\n  mixins: [scoreMixin],\n  data() {\n    return {\n      error: false,\n      userLeft: null,\n      totalScores: [],\n      dices: null,\n      checkedColors: []\n    };\n  },\n  computed: {\n    ...mapGetters(['gameType', 'gameData', 'roundData', 'gameIsOver', 'numPlayers', 'socket', 'myName']),\n    checkActivePlayer() {\n      return typeof this.roundData.activePlayer !== 'undefined';\n    },\n    gameOver() { \n      let filteredArray;\n      if (this.roundData.scoreAdded) {\n        filteredArray = this.roundData.scoreAdded.filter(n => n);\n      }\n      return this.gameIsOver && filteredArray.length === this.numPlayers;\n    },\n    activePlayer() {\n      return this.roundData.activePlayer;\n    },\n    errorType() {\n      if (this.error === this.$t('game.not-enough')) {\n        return 'error';\n      }\n      return 'confirm';\n    },\n    botOwnTurn() {\n      return this.gameType === 'solo' && this.roundData.activePlayer !== 0 && this.roundData.scoreAdded.length === 0\n    },\n    botOthersTurn() {\n      return this.gameType === 'solo' && this.roundData.activePlayer !== 0 && this.roundData.scoreAdded.length !== 0\n    }\n  },\n  methods: {\n    ...mapActions(\n      ['resetRoundData', 'setRoundData', 'setGameData', 'setGameOver', \n      'nextPlayer', 'removePlayer', 'setTotalScore', 'setId', 'setScore']\n    ),\n    startGame() {\n      this.resetRoundData();\n    },\n    passDiceColors(data) {\n      this.checkedColors = data;\n    },\n    calcScores() {\n      this.gameData.forEach((player) => {\n        this.totalScores.push({ name: player.name, score: player.total[9]} );\n      });\n      this.totalScores = this.totalScores.sort((a, b) => b.score - a.score);\n    },\n    calcBonus(player, fieldNo, bonusField, otherField1, otherField2) {\n      if (\n        this.gameData[player][bonusField][fieldNo] > 0 &&\n        this.gameData[player][otherField1][fieldNo] > 0 &&\n        this.gameData[player][otherField2][fieldNo] > 0\n      ) {\n        return this.gameData[player][bonusField][fieldNo];\n      }\n      return 0;\n    },\n    handleError() {\n      if (this.error === this.$t('game.not-enough')) {\n        location.href = '/';\n      }\n      this.error = false;\n    },\n    simulateTurn() {\n      let bot = this.roundData.activePlayer;\n\n      // create color arrays\n      let colors = {\n        red: [[], [], []],\n        yellow: [[], [], []],\n        purple: [[], [], []]\n      }\n\n      // fill color arrays with current scores\n      let colorNames = ['red', 'yellow', 'purple'];\n      let colorFields = {\n        red: [[2,3], [4,6,7], [8,9,10,11]],\n        yellow: [[1,2], [3,4,5], [7,8,9,10]],\n        purple: [[0,1], [2,3,5], [6,7,8,9]]\n      };\n\n      colorNames.forEach(color => {\n        colors[color][0].push(\n          this.gameData[bot][color][colorFields[color][0][0]],\n          this.gameData[bot][color][colorFields[color][0][1]]\n        );\n        colors[color][1].push(\n          this.gameData[bot][color][colorFields[color][1][0]],\n          this.gameData[bot][color][colorFields[color][1][1]],\n          this.gameData[bot][color][colorFields[color][1][2]]\n        );\n        colors[color][2].push(\n          this.gameData[bot][color][colorFields[color][2][0]],\n          this.gameData[bot][color][colorFields[color][2][1]],\n          this.gameData[bot][color][colorFields[color][2][2]],\n          this.gameData[bot][color][colorFields[color][2][3]]\n        );\n      });\n\n      /* determine how many dices to roll */\n      \n      // join color arrays to check where there is room\n      let zeroArr = colors.red[0].concat(colors.yellow[0], colors.purple[0]);\n      let oneArr = colors.red[1].concat(colors.yellow[1], colors.purple[1]);\n      let twoArr = colors.red[2].concat(colors.yellow[2], colors.purple[2]);\n      console.log('zero: ', zeroArr);\n      console.log('one: ', oneArr);\n      console.log('two: ', twoArr);\n      \n      let numDices;\n      let chance = Math.random();\n      // room in every array\n      if (zeroArr.filter(Boolean).length < 6 && oneArr.filter(Boolean).length < 9 && twoArr.filter(Boolean).length < 12) {\n        if (chance <= 0.2) {\n        numDices = 1;\n        } else if (chance <= 0.55) {\n          numDices = 2;\n        } else {\n          numDices = 3\n        }\n      // room in arr 0 + 1\n      } else if (zeroArr.filter(Boolean).length < 6 && oneArr.filter(Boolean).length < 9) {\n        if (chance <= 0.4) {\n          numDices = 1;\n        } else {\n          numDices = 2;\n        }\n      // room in arr 0 + 2\n      } else if (zeroArr.filter(Boolean).length < 6 && twoArr.filter(Boolean).length < 12) {\n        if (chance <= 0.33) {\n          numDices = 1;\n        } else {\n          numDices = 3;\n        }\n      // room in arr 1 + 2\n      } else if (oneArr.filter(Boolean).length < 9 && twoArr.filter(Boolean).length < 12) {\n        if (chance <= 0.4) {\n          numDices = 2;\n        } else {\n          numDices = 3;\n        }\n      // only room in 0\n      } else if (zeroArr.filter(Boolean).length < 6) {\n        numDices = 1\n      // only room in 1\n      } else if (oneArr.filter(Boolean).length < 9) {\n        numDices = 2\n      // only room in 2\n      } else if (twoArr.filter(Boolean).length < 12) {\n        numDices = 3\n      }\n\n      // determine which color dices to use\n      let useColors = [];\n      let usableColors = [];\n    \n      if (numDices === 3) {\n        useColors = ['red', 'yellow', 'purple'];\n      } else if (numDices === 2) {\n          colorNames.forEach(color => {\n          if (colors[color][1].filter(Boolean).length < 3) usableColors.push(color);\n        });\n        let randomUsableColors = this.shuffle(usableColors);\n        if (usableColors.length === 2 || usableColors.length === 3) {\n          useColors.push(randomUsableColors[0], randomUsableColors[1])\n        } else /* length = 1 */ {\n          useColors.push(randomUsableColors[0])\n          if (usableColors[0] === 'red') {\n            useColors.push('yellow');\n          } else if (usableColors[0] === 'yellow') {\n            useColors.push('red');\n          } else if (usableColors[0] === 'purple') {\n            useColors.push('red');\n          }\n        }\n      } else /* numDices === 1 */ {\n        colorNames.forEach(color => {\n          if (colors[color][0].filter(Boolean).length < 2) usableColors.push(color);\n        });\n        let randomUsableColors = this.shuffle(usableColors);\n        useColors.push(randomUsableColors[0])\n      }\n\n      setTimeout(() => {\n        // change dice colors\n        this.$refs.controlDices.checkedColors = useColors;      \n        this.$refs.controlDices.rollDices();    \n        // add score\n        this.addBotScore('own');             \n      }, 2000);\n    },\n    addBotScore(turn) {\n      let total = this.roundData.dices.total;\n      console.log(turn, total);\n      let colorsUsed = [];\n      ['red', 'yellow', 'purple'].forEach(color => {\n        if (this.roundData.dices[color] > 0) colorsUsed.push(color);\n      });\n      \n      // determine possible fields\n      let possibleFields = [];\n      let fieldScores = [\n        [[1], [5]], // 1\n        [[4], [9]], // 2\n        [[6], [10]], // 3\n        [[8], [11]], // 4\n        [[9], [12]], // 5\n        [[10], [13]], // 6\n        [[11], [14]], // 7 \n        [[12], [15]], // 8\n        [[14], [18]], // 9\n      ];\n      fieldScores.forEach((el, i) => {\n        if (total >= el[0] && total <= el[1]) possibleFields.push(i + 1);\n      });\n\n      // randomize colors + fields\n      let randomColors = this.shuffle(colorsUsed);\n      let randomFields = this.shuffle(possibleFields);\n\n      // create new array with colors and original gameData array positions\n      let originalArr = [];\n      randomColors.forEach(color => {\n        originalArr.push({ \n          color, \n          fields: this.originalPosition(randomFields, color) \n        })\n      });\n\n      let scoreData = [];\n      outerLoop:\n      for (let i = 0; i < originalArr.length; i++) {\n        for (let y = 0; y < originalArr[i].fields.length; y++) {\n          let scoreField = originalArr[i].fields[y];\n          let scoreColor = originalArr[i].color;\n          if (this.scoreCheck(scoreField, scoreColor) === true && \n          !this.gameData[this.roundData.activePlayer][scoreColor][scoreField]) {\n            scoreData.push(scoreColor, scoreField);\n            break outerLoop;\n          }\n        }\n      }\n\n      if (scoreData.length === 0 && turn === 'own') { // no compatible field/color found\n        if (this.roundData.remainingRolls > 0) {      \n          console.log('Roll again');    \n          setTimeout(() => {\n            // roll dices again\n            this.$refs.controlDices.rollDices();  \n            // add score\n            this.addBotScore('own'); \n          }, 2000);\n        } else {\n          // enter failed throw\n          setTimeout(() => {\n            this.$refs.card.$refs.failed.confirmFail(true);\n          }, 2000);\n        }\n      } else if (scoreData.length === 0 && turn === 'other') {\n        this.nextPlayer({ next: null }); // nextPlayer already has time-out in action\n      } else { // compatible field/color was found\n        this.pushScore(scoreData);\n      }\n\n    },\n    pushScore(data) {\n      let color = data[0];\n      let field = data[1];\n\n      setTimeout(() => {\n        this.setScore({ \n          color: color, \n          field: field \n        });\n        // Check if winning conditions are met\n        this.calcWinningConditions();\n        this.nextPlayer({ next: null });\n      }, 2000);\n    },\n    originalPosition(arr, color) {\n      // translate field back to position in original gameData array\n      let newArr = arr.map(field => {\n        if ((color === 'red' && field <= 3) || (color === 'yellow' && field >= 6)) {\n          return field = field + 1;\n        } else if (color === 'red' && field >= 4) {\n          return field = field + 2; \n        } else if (color === 'purple' && field <= 4) {\n          return field = field - 1;\n        } else {\n          return field\n        }\n      })\n      \n      return newArr;\n    },\n    shuffle(arr) {\n      let ctr = arr.length;\n      let temp, index;\n\n      // While there are elements in the array\n      while (ctr > 0) {\n        // Pick a random index\n        index = Math.floor(Math.random() * ctr);\n        // Decrease ctr by 1\n        ctr--;\n        // And swap the last element with it\n        temp = arr[ctr];\n        arr[ctr] = arr[index];\n        arr[index] = temp;\n      }\n      return arr;\n    }\n  },\n  watch: {\n    gameOver() {\n      this.gameData.forEach((_, player) => {\n        // Create new array for storing totals row\n        let total = [];\n        // For every color: if array has 9 elements, take last value as score; else take the number of elements as score\n        let colorArray = ['red', 'yellow', 'purple'];\n        colorArray.forEach(color => {\n          let newArray = this.gameData[player][color].filter(n => n);\n          if (newArray.length === 9) {\n            total.push(newArray[8]);\n          } else {\n            total.push(newArray.length);\n          }\n        });\n        total.push(\n          this.calcBonus(player, 3, 'red', 'yellow', 'purple'),\n          this.calcBonus(player, 7, 'red', 'yellow', 'purple'),\n          this.calcBonus(player, 8, 'yellow', 'red', 'purple'),\n          this.calcBonus(player, 2, 'purple', 'red', 'yellow'),\n          this.calcBonus(player, 9, 'purple', 'red', 'yellow')\n        );\n        // -5 points for every failed round\n        let failPoints = 0;\n        this.gameData[player].fail.forEach(element => {\n          failPoints += element;\n        });\n        total.push(failPoints);\n        // Add up everything and store it as the last element of total array\n        total.push(total.reduce((a, b) => a + b, 0));\n        this.setTotalScore({ player: player, total: total });\n      });\n      this.calcScores();\n    },\n    botOwnTurn(newVal) {\n      if (newVal) {\n        this.simulateTurn();\n      }\n    },\n    botOthersTurn(newVal, oldVal) {\n      if (newVal && !oldVal) {\n        this.addBotScore('other');\n      }\n    }\n  },\n  created() {\n    // get localStorage items if there are any\n    let lang = localStorage.getItem('lang');\n    if (lang) this.$i18n.locale = lang;\n\n    let name = localStorage.getItem('name');\n    if (name) this.$store.dispatch('storeName', name);\n\n    this.socket.on('connect', () => {\n      console.log('Connected!', this.socket.id);\n    });\n\n    this.socket.on('roomData', ({ users, started, user }) => {\n      if (this.gameOver) return;\n      if (users.length < 2 && started) {\n        this.error = this.$t('game.not-enough');\n      } else if (started) {\n        this.userLeft = this.gameData[user].name;\n        this.error = `${this.userLeft} ${this.$t('game.left')}...`;\n        if (user === this.roundData.activePlayer) {\n          if (this.roundData.scoreAdded.length === 0) {\n            // determine next player\n            const next = this.roundData.activePlayer === this.gameData.length - 1 ? 0 : this.roundData.activePlayer;\n            this.$store.commit('nextPlayer', { next: next });\n            this.$store.dispatch('resetRoundData');\n          } else {\n            this.nextPlayer({ instant: true, playerLeft: true });\n          }\n        }\n        // remove from gameData\n        setTimeout(() => {\n          this.removePlayer(user);\n          // set new id\n          let id = this.gameData.findIndex(el => el.name === this.myName);\n          this.setId({ id });\n        }, 1000);\n      }\n    });\n\n    this.socket.on('roundData', (data) => {\n      this.setRoundData(data);\n    });\n\n    this.socket.on('gameData', (data) => {\n      this.setGameData({ gameData: data });\n    });\n\n    this.socket.on('gameOver', () => {\n      this.setGameOver();\n    });\n  }\n};\n</script>\n\n<style>\n#app {\n  box-sizing: border-box;\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\na, button, div, span, i, input {\n-webkit-tap-highlight-color: transparent;\n-webkit-touch-callout: none;\n-webkit-user-select: none;\n-khtml-user-select: none;\n-moz-user-select: none;\n-ms-user-select: none;\nuser-select: none;\n}\n\nbody {\n  background: #181b20;\n  color: #2d3748;\n}\n\n.full-width {\n\tleft: 50%;\n\tmargin-left: -50vw;\n\tmargin-right: -50vw;\n\tmax-width: 100vw;\n\tposition: relative;\n\tright: 50%;\n\twidth: 100vw;\n}\n</style>\n"]}]}